<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TaskTree Graph Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden;
            background-color: #1a1a1a;
        }

        #graph {
            width: 100vw;
            height: 100vh;
        }

        .node {
            cursor: pointer;
            stroke-width: 2px;
        }

        .node-label {
            font-size: 10px;
            fill: #e0e0e0;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
        }

        .link {
            stroke: #666;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            border: 1px solid #666;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 300px;
            z-index: 1000;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-label {
            font-weight: bold;
            color: #4fc3f7;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 5px;
            font-size: 16px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e0e0e0;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="graph"></div>
    <div class="tooltip" id="tooltip"></div>
    <div class="loading" id="loading">Loading graph data...</div>

    <script>
        // Configuration
        const API_ENDPOINT = 'http://localhost:8000/api/graph';
        const WIDTH = window.innerWidth;
        const HEIGHT = window.innerHeight;
        
        // Status colors
        const STATUS_COLORS = {
            'pending': '#2196F3',      // Blue
            'in_progress': '#FFC107',  // Yellow/Amber
            'completed': '#4CAF50'     // Green
        };

        // Create SVG
        const svg = d3.select('#graph')
            .append('svg')
            .attr('width', WIDTH)
            .attr('height', HEIGHT);

        // Define arrowhead marker for directed edges
        svg.append('defs').append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 20)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#666');

        // Create container for zoom/pan
        const container = svg.append('g');

        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                container.attr('transform', event.transform);
            });

        svg.call(zoom);

        // Initialize force simulation
        const simulation = d3.forceSimulation()
            .force('link', d3.forceLink().id(d => d.name).distance(150))
            .force('charge', d3.forceManyBody().strength(-400))
            .force('center', d3.forceCenter(WIDTH / 2, HEIGHT / 2))
            .force('collision', d3.forceCollide().radius(30));

        // Graph elements
        let linkGroup = container.append('g').attr('class', 'links');
        let nodeGroup = container.append('g').attr('class', 'nodes');
        let labelGroup = container.append('g').attr('class', 'labels');

        let link, node, label;

        // Tooltip
        const tooltip = d3.select('#tooltip');

        function showTooltip(event, d) {
            const content = `
                <div><span class="tooltip-label">Task:</span> ${d.name}</div>
                <div><span class="tooltip-label">Description:</span> ${d.description || 'N/A'}</div>
                <div><span class="tooltip-label">Status:</span> ${d.status}</div>
                <div><span class="tooltip-label">Priority:</span> ${d.priority}</div>
                <div><span class="tooltip-label">Available:</span> ${d.is_available ? 'Yes' : 'No'}</div>
                ${d.completed_at ? `<div><span class="tooltip-label">Completed:</span> ${d.completed_at}</div>` : ''}
            `;
            
            tooltip.html(content)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY + 10) + 'px')
                .classed('visible', true);
        }

        function hideTooltip() {
            tooltip.classed('visible', false);
        }

        function getNodeColor(d) {
            return STATUS_COLORS[d.status] || '#999';
        }

        function getNodeRadius(d) {
            // Scale radius based on priority (0-10) -> (8-20)
            return 8 + (d.priority / 10) * 12;
        }

        function getNodeStroke(d) {
            // Highlight available tasks with a bright border
            return d.is_available ? '#00FF00' : '#333';
        }

        function getNodeStrokeWidth(d) {
            return d.is_available ? 3 : 2;
        }

        function updateGraph(graphData) {
            // Update loading state
            d3.select('#loading').style('display', 'none');

            // Store current positions BEFORE data update
            const positionCache = new Map();
            if (node) {
                node.each(d => {
                    positionCache.set(d.name, {
                        x: d.x,
                        y: d.y,
                        vx: d.vx || 0,
                        vy: d.vy || 0,
                        fx: d.fx,
                        fy: d.fy
                    });
                });
            }

            // Convert edges from {from, to} to {source, target}
            const links = graphData.edges.map(e => ({
                source: e.from,
                target: e.to
            }));

            const nodes = graphData.nodes;

            // Store previous counts for change detection
            const previousNodeCount = positionCache.size;
            const previousLinkCount = link ? link.size() : 0;

            // Update links
            link = linkGroup.selectAll('.link')
                .data(links, d => `${d.source}-${d.target}`);

            link.exit().remove();

            const linkEnter = link.enter()
                .append('path')
                .attr('class', 'link');

            link = linkEnter.merge(link);

            // Update nodes
            node = nodeGroup.selectAll('.node')
                .data(nodes, d => d.name);

            node.exit().remove();

            const nodeEnter = node.enter()
                .append('circle')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip);

            node = nodeEnter.merge(node);

            // Restore positions for existing nodes AFTER data join
            node.each(d => {
                const cached = positionCache.get(d.name);
                if (cached) {
                    d.x = cached.x;
                    d.y = cached.y;
                    d.vx = cached.vx;
                    d.vy = cached.vy;
                    d.fx = cached.fx;
                    d.fy = cached.fy;
                }
                // New nodes will get default force-directed positions
            });

            node.attr('r', getNodeRadius)
                .attr('fill', getNodeColor)
                .attr('stroke', getNodeStroke)
                .attr('stroke-width', getNodeStrokeWidth);

            // Update labels
            label = labelGroup.selectAll('.node-label')
                .data(nodes, d => d.name);

            label.exit().remove();

            const labelEnter = label.enter()
                .append('text')
                .attr('class', 'node-label')
                .attr('dy', 4);

            label = labelEnter.merge(label);

            label.text(d => d.name.length > 20 ? d.name.substring(0, 18) + '...' : d.name);

            // Detect structural changes
            const structureChanged = 
                nodes.length !== previousNodeCount ||
                links.length !== previousLinkCount;

            // Update simulation
            simulation.nodes(nodes).on('tick', ticked);
            simulation.force('link').links(links);
            
            // Only reheat simulation if structure changed
            if (structureChanged) {
                simulation.alpha(0.3).restart();
            } else {
                // Just a gentle nudge for property updates
                simulation.alpha(0.05).restart();
            }
        }

        function ticked() {
            link.attr('d', d => {
                const sourceX = d.source.x;
                const sourceY = d.source.y;
                const targetX = d.target.x;
                const targetY = d.target.y;
                
                // Calculate the direction vector
                const dx = targetX - sourceX;
                const dy = targetY - sourceY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist === 0) return `M${sourceX},${sourceY}L${targetX},${targetY}`;
                
                // Adjust the end point to stop at the target node's edge
                const targetRadius = getNodeRadius(d.target);
                const offsetX = (dx / dist) * targetRadius;
                const offsetY = (dy / dist) * targetRadius;
                
                const adjustedTargetX = targetX - offsetX;
                const adjustedTargetY = targetY - offsetY;
                
                return `M${sourceX},${sourceY}L${adjustedTargetX},${adjustedTargetY}`;
            });

            node.attr('cx', d => d.x)
                .attr('cy', d => d.y);

            label.attr('x', d => d.x)
                .attr('y', d => d.y);
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function showError(message) {
            d3.select('#loading').style('display', 'none');
            
            const errorDiv = d3.select('body')
                .append('div')
                .attr('class', 'error-message')
                .text(message);
            
            setTimeout(() => errorDiv.remove(), 5000);
        }

        async function fetchGraph() {
            try {
                const response = await fetch(API_ENDPOINT);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                updateGraph(data);
            } catch (error) {
                console.error('Error fetching graph:', error);
                showError(`Failed to fetch graph: ${error.message}`);
            }
        }

        // Initial fetch
        fetchGraph();

        // Auto-refresh every 3 seconds
        setInterval(fetchGraph, 3000);

        // Handle window resize
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            
            svg.attr('width', newWidth).attr('height', newHeight);
            
            simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
            simulation.alpha(0.3).restart();
        });
    </script>
</body>
</html>
